using System;
using System.Threading;

namespace GSR.Audio;

// TODO: previously I tried a threading approach which offloaded resampling to a separate thread...
// that approach was very complicated and audio did not work at all for reasons I can't comprehend
// thus, resampling is done on the emu thread, and we let SDL handle obtaining samples in its audio callback (called on a separate thread anyways)
public sealed class AudioManager : IDisposable
{
	internal const int SAMPLE_BATCH_MS = 5;
	public const int MINIMUM_BUFFER_MS = 20;
	public const int MAXIMUM_BUFFER_MS = 100;

	private readonly Thread _audioThread;
	private readonly object _audioThreadLock = new();

	private volatile bool _disposing;
	private volatile Exception _audioThreadException;

	private readonly AudioRingBuffer _inputBuffer = new();
	private int _inputAudioFrequency;
	private int _bufferMs;

	private readonly BlipBuffer _resampler;
	private uint _resamplerBatchTime;
	private uint _resamplerTime;
	private int _lastL, _lastR;
	private short[] _inputResamplingBuffer;
	private short[] _outputResamplingBuffer;

	private readonly SDLAudioSink _audioSink;
	private int OutputAudioFrequency => _audioSink.Frequency;

	public void Reset()
	{
		lock (_audioThreadLock)
		{
			CheckAudioThreadException();
			_inputBuffer.Reset(_inputAudioFrequency * _bufferMs / 1000 * 2, full: true);
			_resamplerBatchTime = (uint)(_inputAudioFrequency * SAMPLE_BATCH_MS / 1000);
			_resamplerTime = 0;
			_lastL = _lastR = 0;
			_inputResamplingBuffer = new short[_resamplerBatchTime * 2];
			_outputResamplingBuffer = new short[OutputAudioFrequency * (SAMPLE_BATCH_MS + 1) / 1000 * 2];
			_resampler.SetRates(_inputAudioFrequency, OutputAudioFrequency);
			_resampler.Clear();
		}
	}

	public void SetInputAudioFrequency(int freq)
	{
		if (_inputAudioFrequency != freq)
		{
			lock (_audioThreadLock)
			{
				_inputAudioFrequency = freq;
				Reset();
			}
		}
	}

	public void SetBufferMs(int bufferMs)
	{
		lock (_audioThreadLock)
		{
			_bufferMs = bufferMs;
			Reset();
		}
	}

	public void CheckAudioDevice()
	{
		if (_audioSink.DeviceNeedsReset)
		{
			lock (_audioThreadLock)
			{
				_audioSink.ResetDevice();
				Reset();
			}
		}
	}

	public void DispatchAudio(ReadOnlySpan<short> samples)
	{
		CheckAudioThreadException();
		_inputBuffer.Write(samples);
	}

	private void AudioThreadProc()
	{
		try
		{
			while (!_disposing)
			{
				int inputWaitTime, outputWaitTime;
				lock (_audioThreadLock)
				{
					var samplesAvailable = _inputBuffer.Read(_inputResamplingBuffer);
					for (var i = 0; i < samplesAvailable; i += 2)
					{
						var l = (int)_inputResamplingBuffer[i + 0];
						var r = (int)_inputResamplingBuffer[i + 1];
						_resampler.AddDelta(_resamplerTime++, l - _lastL, r - _lastR);
						_lastL = l;
						_lastR = r;

						if (_resamplerTime == _resamplerBatchTime)
						{
							_resamplerTime = 0;
							_resampler.EndFrame(_resamplerBatchTime);
							var samplesAvail = _resampler.ReadSamples(_outputResamplingBuffer);
							_audioSink.DrainAudio(_outputResamplingBuffer.AsSpan()[..(int)(samplesAvail * 2)]);
						}
					}

					var inputSamplesNeeded = (int)(_resamplerBatchTime - _resamplerTime) - _inputBuffer.BufferUsed() / 2;
					inputWaitTime = Math.Max(inputSamplesNeeded * _inputAudioFrequency / 1000, 0);
					outputWaitTime = Math.Max(SAMPLE_BATCH_MS - _audioSink.SamplesAvail * OutputAudioFrequency / 1000, 0);
				}

				Thread.Sleep(Math.Max(inputWaitTime, outputWaitTime));
			}
		}
		catch (Exception e)
		{
			_audioThreadException = e;
		}
	}

	private void CheckAudioThreadException()
	{
		if (_audioThreadException != null)
		{
			throw _audioThreadException;
		}
	}

	public AudioManager(int bufferMs, string deviceName)
	{
		_inputAudioFrequency = 48000;
		_bufferMs = bufferMs;

		try
		{
			_audioSink = new(deviceName);
			_resampler = new((uint)(OutputAudioFrequency * (SAMPLE_BATCH_MS + 1) / 1000));
			Reset();

			_audioThread = new(AudioThreadProc) { IsBackground = true };
			_audioThread.Start();
		}
		catch
		{
			Dispose();
			throw;
		}
	}

	public void Dispose()
	{
		_disposing = true;
		_audioThread?.Join();
		_audioSink?.Dispose();
		_resampler?.Dispose();
	}
}
